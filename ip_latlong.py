#!/usr/bin/env python3

##
# @file ip_latlong.py
#
# @brief BrightSign Simple Coding Homework Assignment--CLI tool to find
#        latitude and longitude for an IP address using the IPStack API.
#
# @details A command line interface for Mac and Linux that uses IPStack's API
#          to determine the latitude and longitude of an IP address.
#          Takes a single IPv4 or IPv6 address as input. There are other ways
#          to encode IP addresses, but it seems, empirically, that IPStack
#          does not support things like decimal, binary, or octal
#          representations. Curiously, they do seem to support FQDNs, but that
#          is beyond the scope of this project.
#
#          This software requires an IPStack API key that must be supplied as
#          an environment variable prior to the execution of this program.
#
# @section notes_doxygen Notes
# @section todo_doxygen TODO
# @section author_doxygen Author(s)
# - Created by Maya Nigrosh on 10 Dec 2023
import enum
import platform
import sys
import os
import ipaddress
import requests
import json
import logging

## Name for the environment variable that will hold our IPStack API key
API_KEY_ENV_VAR_NAME = "API_KEY"
## IPStack's domain
IPSTACK_FQDN = "api.ipstack.com"
## Fields we'll be requesting as part of our query to IPStack
QUERY_FIELDS = "latitude,longitude"
## Timeout, in seconds, for a request to IPStack
REQUEST_TIMEOUT = 3
## Number of decimal places to which to output latitude and longitude
## We are likely trying to find a room in a building, so we can use
## https://xkcd.com/2170/ to guide us to this number
DEFAULT_LAT_LONG_PRECISION = 4
## While evaluating received data from the requests module, how many octets
## to process at a time
REQUESTS_BLOCKSIZE = 64
## The maximum octets in a response. IPStack should not be returning giant
## blobs of data to us, and this will protect (a little) against a data DOS.
## Note that this will have to change if we alter QUERY_FIELDS and suddenly
## start receiving more (or less) data.
MAX_RESPONSE_OCTETS = 256
## Default log level to display on console.
LOGGING_LEVEL = logging.WARNING

# Do some checks on the operating system. Right now, we don't seem to do
# anything special for either MacOS or Linux, but this is here in case there
# are any predicates for either OS. Also to tell Windows users this program is
# not designed to work on their primary OS.
if platform.system() == "Darwin":
    pass
elif platform.system() == "Linux":
    pass
else:
    logging.error(f"Sorry, but this won't run on {platform.system()}")
    # We could have used ReturnCode.INVALID_OS, but that would require
    # putting this code block after the class definition, which feels like
    # it's burying it a little too much for readability.
    sys.exit(1)


class ReturnCode(enum.IntEnum):
    """!
    An enumeration describing the various return codes that could be the
    result of running this program. There are other return codes that may
    be emitted by this program besides these. Those return codes are
    generated by the IPStack API and can be found in the
    Error Codes / Other Errors section of
    https://ipstack.com/documentation
    """
    ## Everything has worked correctly.
    SUCCESS = 0
    ## This is an unsupported operating system.
    INVALID_OS = 1
    ## Something is wrong about the argument passed on the command line.
    BAD_INPUT = 2
    ## The argument provided on the commandline is not a valid IP address.
    INVALID_IP = 3
    ## The API_KEY environment variable has not been set before the running of
    ## this program.
    NO_API_KEY = 4
    ## For whatever reason, we were not able to contact the IPStack servers in
    ## a reasonable amount of time.
    NETWORK_TIMEOUT = 5
    ## When IPStack can't find a location for an address, it defaults to 0
    ## degrees latitude and 0 degrees longitude. You can test that out by
    ## handing it a private ip. But, it turns out that (0, 0) is actually a
    ## completely valid latitude and longitude in the middle of the Atlantic
    ## Ocean. After hearing Peng Shepherd, author of The Cartographers, give a
    ## lecture in which she shared an anecdote about the family farm that's
    ## technically at the geographic center of the United States--detailing
    ## all of the vistors they've gotten over the years and all of the packages
    ## that have been erroneously delivered to them--it seemed prudent NOT to
    ## allow my program to cause the same problem.
    INVALID_LATLONG = 6
    ## Something did not succeed when trying to extract information from the
    ## IPStack server.
    COMMUNICATION_FAILURE = 7
    ## The IPStack request went through, but the failure message contained
    ## details.
    FAILED_WITH_DETAIL = 8
    ## The IPStack request went through, but it gave us a message we do not
    ## have the capacity to understand.
    UNRECOGNIZED_RESPONSE = 9


def usage():
    """!
    Prints usage information.
    """
    logging.error("Usage:")
    logging.error(f"\tpython3 {os.path.basename(__file__)} <IP address>")


def validIP(input_arg):
    """!
    Given some input, check to see if it is a valid IP address. This will weed
    out things that are the wrong data type, like a word, but also things that
    seem like they could be IP addresses, like 111.111.222.333 or
    00000:1111:2222:3333:4444:5555:6666:7777, but actually are not.

    @param input_arg Value originally passed to the program on the command
                     line.

    @returns boolean indicating whether or not this is a valid IP address.
                     Returns True for correctly formatted IP addresses and
                     False for anything else.
    """
    try:
        ip = ipaddress.ip_address(input_arg)
    except ValueError:
        return False

    # We're only allowing IPv4 and IPv6 addresses.
    # Not sure how you'd even put in an IPv3 address, and IPv5 basically
    # overlapped the IPv4 address space, but...
    if ip.version not in [4, 6]:
        return False

    return True


def makeRequest(ip):
    """!
    Constructs the appropriate URL for a query to IPStack for the requested
    IP address. Sends that request and returns the information gathered from
    the server, or None in the case of a communication failure.

    @param ip A valid IPv4 or IPv6 address in string format (dotted quads or
              colon-separated clusters).
    @returns JSON object containing the received data, or None in the case of
             a failure. Note that returning JSON does not necessarily mean that
             the lookup for the IP address was successful, since the error
             message from IPStack is also JSON, as is its completely
             undocumented "detail" message.
    @sideeffect In the event that the API_KEY environment variable has not
                been set before execution, this function will exit the entire
                program.
    @sideeffect If communications with IPStack result in a timeout or a
                communication error, the appropriate return code will be set,
                and this function will exit the entire program.
    """
    # Pull the API key from the environment. This will have been put there
    # by the docker container, or will have to be added within the shell
    # before the script is called.
    try:
        api_key = os.environ[API_KEY_ENV_VAR_NAME]
    except KeyError:
        logging.error("Please set the API_KEY environment variable before running this program again")  # noqa: 501
        sys.exit(ReturnCode.NO_API_KEY)

    # Build up the URL.
    # Since we're using a free account, we can only use HTTP as a scheme.
    url = f"http://{IPSTACK_FQDN}/{ip}?access_key={api_key}&fields={QUERY_FIELDS}"  # noqa: 501

    try:
        # Setting this up as a stream so that we don't receive all of the input
        # in one giant block. This can help with spotty connections and with
        # protecting against an overload of data.
        req = requests.get(url, stream=True, timeout=REQUEST_TIMEOUT)
        req.raise_for_status()

        processed_size = 0
        content = bytes()

        for block in req.iter_content(chunk_size=REQUESTS_BLOCKSIZE):
            processed_size += len(block)

            if processed_size > MAX_RESPONSE_OCTETS:
                raise BufferError("Too much returned data for request")

            content += block

    except BufferError:
        logging.error("Server returned an unexpected amount of data as its response.")  # noqa: 501
        return None
    except requests.ConnectionError as ce:
        logging.error(f"Unable to connect to IPStack: {ce}")
        sys.exit(ReturnCode.COMMUNICATION_FAILURE)
    except requests.exceptions.HTTPError as http_e:
        logging.error(f"HTTP Error: {http_e}")
        return None
    except requests.Timeout as t:
        logging.warning(f"We timed out: {t}")
        sys.exit(ReturnCode.NETWORK_TIMEOUT)
    except Exception as generic_exception:
        logging.error(f"Request did not go through: {generic_exception} of type {type(generic_exception)}")  # noqa: 501
        return None

    try:
        # The requests library has its own JSON parser, but since we've
        # pre-processed the byte array, we can't use it. We'll do this the same
        # way we'd parse JSON that came in via a different mechanism.
        decoded_content = content.decode('utf8')
        json_content = json.loads(decoded_content)
    except UnicodeDecodeError as ude:
        logging.warning(f"Unable to decode response as UTF-8: {ude}")
        return None
    except json.JSONDecodeError as jde:
        logging.warning(f"Unable to decode JSON: {jde}")
        return None

    return json_content


def processResults(json_content):
    """!
    Given a JSON object, parse out the data to extract a string with the
    latitude and longitude, or to discover the cause of any error.

    @param json_content JSON-formatted response received from IPStack

    @returns string A string representing the coordinates for the latitude and
                    longitude corresponding to the IP address, or the error
                    text returned by IPStack.
    @returns number In the case of an error, the numeric code assigned by
                    IPStack for that error. In the case of success, None.
    """
    # So there are a few possibilities for output.
    # One is exactly what we've requested, a response that looks something like
    # {
    #   'longitude': 145.18063354492188,
    #   'latitude : -37.7036018371582
    # }
    #
    # Another is that there has been some sort of error, in which case we'll
    # see something that looks like
    # {
    #   'success': false,
    #   'error': {
    #     'code': 101,
    #     'type': 'missing_access_key',
    #     'info': 'No API Key was specified.'
    #   }
    # }
    #
    # And the last one appears to be undocumented, but can be returned when
    # a bad IPStack URI path is provided, like "http://{IPSTACK_FQDN}/foo/"
    # It looks something like
    # {
    #   'detail': 'Not Found'
    # }

    # Test for the error case first so we can short-circuit out quickly.
    try:
        error = json_content["error"]
        # extract the "error.code" field
        error_code = error["code"]
        # extract the "error.info" field
        error_info = error["info"]
        return error_info, error_code
    # We *want* the KeyError--this means that IPStack didn't identify an error
    # with the response to our request.
    except KeyError:
        try:
            latitude = json_content["latitude"]
            longitude = json_content["longitude"]
        # It's possible that something besides "error" can be returned.
        # Empirical poking found some requests have "detail" in them.
        # Let's examine that possibility, too. (This time, we *don't want* the
        # KeyError.
        except KeyError:
            try:
                detail = json_content["detail"]
                return detail, ReturnCode.FAILED_WITH_DETAIL
            # If it doesn't have "detail" in it, now we really don't know
            # what IPStack is talking about.
            except Exception as detail_e:
                logging.warning(f"Received a response we cannot recognize: {detail_e}")  # noqa: 501
                return detail_e, ReturnCode.UNRECOGNIZED_RESPONSE
        # If we've gotten here, then the response didn't have "latitude" and
        # "longitude" in it, but it also wasn't an error, or that "detail"
        # thing. What even is this???
        except Exception as e:
            logging.warning(f"Something failed extracting the longitude and latitude: {e} of type {type(e)} with data {json_content}")  # noqa: 501
            return None, None
    except Exception as generic_e:
        logging.warning(f"Something went wrong parsing the JSON: {generic_e}")

    # This is our special case where IPStack returns a valid location in the
    # world when it means that it actually can't trace this IP.
    # Check back to the comment on INVALID_LATLONG to explain why we're doing
    # this.
    if latitude == 0 and longitude == 0:
        return None, None

    truncated_latitude = round(latitude, DEFAULT_LAT_LONG_PRECISION)
    truncated_longitude = round(longitude, DEFAULT_LAT_LONG_PRECISION)

    latlong_string = f"({truncated_latitude}, {truncated_longitude})"

    return latlong_string, None


def main():
    """!
    Main method.
    Accepts a single input from the command line and attempts to query IPStack
    to find out the latitude and longitude for that IP address.
    """
    logging.basicConfig(format='<%(levelname)s>: %(message)s',
                        level=LOGGING_LEVEL)

    # Make sure there's only the one argument.
    if (len(sys.argv) - 1) != 1:
        usage()
        sys.exit(ReturnCode.BAD_INPUT)

    ip = sys.argv[1]

    if not validIP(ip):
        logging.error(f"{ip} is not a valid IP address")
        sys.exit(ReturnCode.INVALID_IP)

    # Send the message off to IPStack
    ipstack_response = makeRequest(ip)

    if None is ipstack_response:
        sys.exit(ReturnCode.COMMUNICATION_FAILURE)

    # Take what IPStack has given us and see if we can find it on a globe.
    ret_string, error_code = processResults(ipstack_response)

    if None is ret_string:
        logging.warning("The lat/long for this IP is invalid")
        sys.exit(ReturnCode.INVALID_LATLONG)

    # If we got an error back from IPStack
    if None is not error_code:
        logging.warning(f"{ret_string}")
        sys.exit(error_code)

    print(ret_string)

    sys.exit(ReturnCode.SUCCESS)


if __name__ == '__main__':
    sys.exit(main())
